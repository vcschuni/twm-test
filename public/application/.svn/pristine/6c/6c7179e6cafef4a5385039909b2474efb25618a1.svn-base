class LayerEditor {
	/**
	 * Function: constructor
	 * @param () none
	 * @returns () nothing
	 * Function that initializes the class
	 */
	constructor() {
		this.name = "LayerEditor";
		this.version = 1.0;
		this.author = "";
		this.pcfg = getPluginConfig(this.name);
		this.tabName = this.pcfg.tabName ? this.pcfg.tabName : "Layer Editor";
		this.tabContentFile = "application/plugins/LayerEditor/tab-content.html";
		this.tabNav;
		this.tabContent;
		this.editableLayer;
		this.editableLayerTopId;
		this.snapableCollection = new ol.Collection(); // Store features to snap too.
		this.editableFeature;
		this.featurePendingChangeCount = 0;
		this.addPlugin(); // Initializes the plugin

		// Define and add an empty RED highlight layer
		this.redHighlightLayer = new ol.layer.Vector({
			source: new ol.source.Vector({}),
			style: new ol.style.Style({
				stroke: new ol.style.Stroke({
					color: "rgba(255, 0, 0, 0.6)",
					width: 8
				})
			})
		});
		app.map.addLayer(this.redHighlightLayer);
		this.redHighlightLayer.setZIndex(651);
	}

	/**
	 * Function: turnEditingOff
	 * @param () none
	 * @returns () nothing
	 * Function to turn off all editing functionality
	 */
	turnEditingOff() {
		// Remove the interactions
		if (this.modify) app.map.removeInteraction(this.modify);
		if (this.select) app.map.removeInteraction(this.select);
		if (this.draw) app.map.removeInteraction(this.draw);
		if (this.snap) app.map.removeInteraction(this.snap);
		if (this.delete) app.map.removeInteraction(this.delete);
		if (this.dragBox) app.map.removeInteraction(this.dragBox);

		// Turn off red highlighting on hover
		this.redHighlightLayer.getSource().clear();
		app.map.un("pointermove", this.highlightFeatureOnHover);

		// Reset default single click function
		resetDefaultMapSingleClickFunction();

		// Clear and hide attribute editing
		this.populateFeatureEditorSelector(null);

		// Empty and hide copy features list
		$("#le-copying-container").empty();
		$("#le-copying-container").hide();
	}

	/**
	 * Function: populateFeatureEditorSelector
	 * @param (object) features
	 * @returns () nothing
	 * Function to populate and show the editable features (if more than one was selected)
	 */
	populateFeatureEditorSelector(features) {
		// Reset editable feature selector and form
		$("#le-editable-feature-select").parent().hide();
		$("#le-editable-feature-select").empty();
		this.showAttributeEditingForm(null);
		
		// Bail if no features were passed
		if (features == null) return;
		if (features.length == 0) return;
		
		// Build the feature name
		var titleFields = [];
		$.each(this.editableLayer.get("fields"), function (index, field) {
			if (field.title) titleFields.push(field.name);
		});
		
		// Populate the editable feature selector with the passed features
		$.each(features, function (index, feature) {
			var properties = feature.getProperties();
			var titleValues = [];
			titleValues.push(feature.getId());
			$.each(titleFields, function (index, titleField) {
				if (properties[titleField]) titleValues.push(properties[titleField]);
			});
			var title = titleValues.join(" - ");
			var option = $("<option></option>");
			option.attr("value", feature.getId());
			option.html(title);
			$("#le-editable-feature-select").append(option);
		});
		
		// Show the editable feature selector
		$("#le-editable-feature-select").parent().show();
		
		// Set the first feature as editable
		this.showAttributeEditingForm(features[0].getId());
	}

	/**
	 * Function: showAttributeEditingForm
	 * @param (integer) featureId
	 * @returns () nothing
	 * Function to populate and show the passed feature's attribute editing form
	 */
	showAttributeEditingForm(featureId) {
		// Reset the attribute editing form
		tinymce.remove("textarea.le-attr-htmleditor");
		$("#le-attribute-form .le-attr-input-div").remove();
		$("#le-attribute-form").hide();
		$("#le-attribute-save-btn").hide();
		app.plugins.LayerEditor.featurePendingChangeCount = 0;
				
		// Close an existing popup if necessary
		closePopup();
		
		// Bail if a null featureId was passed
		if (!featureId) return;
		
		// Set the editable feature
		this.editableFeature = this.editableLayer.getSource().getFeatureById(featureId);
		
		// Make the focus feature the only one in the select set
		if (app.plugins.LayerEditor.select) {
			app.plugins.LayerEditor.select.getFeatures().clear();
			app.plugins.LayerEditor.select.getFeatures().push(this.editableFeature);
		}

		// Get feature properties
		var featureProperties = this.editableFeature.getProperties();
		
		// Add each key and value as a row
		Object.keys(featureProperties).forEach((key) => {
			// Skip if the geometry column
			if (key === app.plugins.LayerEditor.editableLayer.getSource().geometryColumnName) return;

			// Get configured field details
			var prettyFieldName = key;
			var editable = false;
			var valueOptions = [];
			var htmlEditor = false;
			$.each(this.editableLayer.get("fields"), function (index, field) {
				if (field.name === key) {
					if (field.editable) editable = true;
					if (field.nameTransform) prettyFieldName = field.nameTransform();
					if (field.valueOptions) valueOptions = field.valueOptions;
					if (field.htmlEditor) htmlEditor = field.htmlEditor;
				}
			});

			// Get field datatype (if exists)
			var dataType = "string";
			if (this.editableLayer.get("attributes")) {
				$.each(this.editableLayer.get("attributes"), function (index, attribute) {
					if (attribute.name === key) {
						if (attribute.localType) dataType = attribute.localType;
					}
				});
			}

			// Get the field value
			var value = featureProperties[key];

			// Build attribute input (based on data type)
			var input;
			switch (dataType) {
				case "string":
					// Basic text field or html editor if requested
					if (valueOptions.length == 0) {
						// HTML editor
						if (htmlEditor === true) {
							input = $(".le-attr-input-template-htmleditor").clone(true);
							input.removeClass("le-attr-input-template-htmleditor");
							input.find("span").html(prettyFieldName);
							input.find("textarea").addClass("le-attr-htmleditor");
							input.find("textarea").attr("key", key);
							input.find("textarea").val(value);
							input.find("textarea").data("original-value", value);
							if (!editable) input.find("textarea").prop("disabled", true);

						// Basic text field
						} else {
							input = $(".le-attr-input-template-text").clone(true);
							input.removeClass("le-attr-input-template-text");
							input.find("span").html(prettyFieldName);
							input.find("input").attr("key", key);
							input.find("input").val(value);
							input.find("input").data("original-value", value);
							if (!editable) input.find("input").prop("disabled", true);
						}

					// Option list controlled field
					} else {
						input = $(".le-attr-input-template-option").clone(true);
						input.removeClass("le-attr-input-template-option");
						input.find("span").html(prettyFieldName);
						input.find("select").attr("key", key);
						$.each(valueOptions, function (index, value) {
							var option = $("<option></option>");
							option.attr("value", value);
							option.html(value);
							input.find("select").append(option);
							$("#myselect").val([1, 3, 4]).trigger("change");
						});
						input.find("select").val(value);
						input.find("select").data("original-value", value);
						if (!editable) input.find("select").prop("disabled", true);
					}
					break;
					
				case "number":
					// Open number field
					if (valueOptions.length == 0) {
						input = $(".le-attr-input-template-number").clone(true);
						input.removeClass("le-attr-input-template-number");
						input.find("span").html(prettyFieldName);
						input.find("input").attr("key", key);
						input.find("input").val(value);
						input.find("input").data("original-value", value);
						if (!editable) input.find("input").prop("disabled", true);

					// Option list controlled field
					} else {
						input = $(".le-attr-input-template-option").clone(true);
						input.removeClass("le-attr-input-template-option");
						input.find("span").html(prettyFieldName);
						input.find("select").attr("key", key);
						$.each(valueOptions, function (index, value) {
							var option = $("<option></option>");
							option.attr("value", value);
							option.html(value);
							input.find("select").append(option);
							$("#myselect").val([1, 3, 4]).trigger("change");
						});
						input.find("select").val(value);
						input.find("select").data("original-value", value);
						if (!editable) input.find("select").prop("disabled", true);
					}
					break;
					
				case "date-time":
					if (value.slice(-1) == "Z") {
						value = value.substring(0, value.length - 1);
					}
					input = $(".le-attr-input-template-datetime").clone(true);
					input.removeClass("le-attr-input-template-datetime");
					input.find("span").html(prettyFieldName);
					input.find("input").attr("key", key);
					input.find("input").val(value);
					input.find("input").data("original-value", value);
					if (!editable) input.find("input").prop("disabled", true);
					break;
			}

			// Add attribute input
			if (input) {
				$("#le-attribute-form").append(input);
				input.show();
			}
		});

		// Show attribute editing form
		$("#le-attribute-form").show();

		// Add change listeners to inputs
		$("#le-attribute-form .le-form-input").on("input", (e) => {
			// Get the input
			var input = $(e.target);
			var originalValue = input.data("original-value");
			var currentValue = input.val();

			// Track change
			if (originalValue != currentValue) {
				app.plugins.LayerEditor.featurePendingChangeCount++;
			} else {
				if (app.plugins.LayerEditor.featurePendingChangeCount > 0) app.plugins.LayerEditor.featurePendingChangeCount--;
			}
			
			// Hide/show save button
			if (app.plugins.LayerEditor.featurePendingChangeCount > 0) {
				$("#le-attribute-save-btn").show();
			} else {
				$("#le-attribute-save-btn").hide();
			}

			// Modify the focus feature attribute
			if (input.prop("disabled") === false) {
				// Get the key/value
				var key = input.attr("key");
				var value = input.val();

				// Update the feature
				var feature = $("#le-editable-feature-select option:selected").data("feature");

				// Set the editable features new property
				this.editableFeature.set(key, value);
			}
		});
	
		// Initialize html editors if required
		tinymce.init({
			selector: "textarea.le-attr-htmleditor",
			promotion: false,
			license_key: "gpl",
			menubar: false,
			toolbar: "undo redo bold italic alignleft aligncenter alignright alignjustify indent outdent",
			toolbar_mode: "wrap",
			statusbar: false,
			height: 200,
			setup: function(editor){
				editor.on("input", (e) => {
					var assocTextAreaElement = $("#" + editor.id);
					assocTextAreaElement.val(editor.getContent());
					assocTextAreaElement.trigger("input");
				});
			}
		});		
	}

	/**
	* Function: executeWFSTransaction
	 * @param (array) added
	 * @param (array) modified
	 * @param (array) removed
	 * @param (function) callback
	 * @returns () nothing
	 * Function to add/modify/remove feature via WFS-T transaction
	 */
	executeWFSTransaction(added, modified, removed, callback) {
		// Show the map spinner
		showMapSpinner();

		// Handle optional parameters
		callback = callback || function () {};

		// Define the WFS format
		var formatWFS = new ol.format.WFS();

		// Define the GML format
		var formatGML = new ol.format.GML({
			featureNS:
			app.plugins.LayerEditor.editableLayer.getSource().layerNamespace,
			featureType: app.plugins.LayerEditor.editableLayer.getSource().layerName,
			version: "1.1.0",
			geometryName:
			app.plugins.LayerEditor.editableLayer.getSource().geometryColumnName,
			srsName: app.map.getView().getProjection().getCode()
		});

		// Build the xml packet
		var xml = formatWFS.writeTransaction(added, modified, removed, formatGML);

		// Convert xml packet to a string
		var data = new XMLSerializer().serializeToString(xml);

		// Replace typeName="feature:<layer_name>" with typeName="<layer_namespace>:<layer_name>"
		data = data.replace(
			/typeName="feature:/,
			'typeName="' + this.editableLayer.getSource().layerNamespace + ":"
		);

		// Post the transaction packet to the WFS-T endpoint
		$.ajax({
			type: "POST",
			url: app.plugins.LayerEditor.editableLayer.getSource().layerUrl,
			contentType: "text/xml",
			dataType: "xml",
			processData: false,
			data: data
		})

		// Handle a valid response
		.done(function (response) {
			hideMapSpinner();
			var result = formatWFS.readTransactionResponse(response);
			callback(true, result);
		})

		// Handle a failure
		.fail(function (jqxhr, settings, exception) {
			hideMapSpinner();
			logger(
				"ERROR",
				"Error commiting transaction to " + app.plugins.LayerEditor.editableLayer.getSource().layerUrl + " [" + exception + "]"
			);

			// Warn user of error and give them a chance to retry.
			bootbox.dialog({
				title: "ERROR",
				message: "Could not modify '<i>" + app.plugins.LayerEditor.editableLayer.get("title") + "</i>'",
				size: "small",
				closeButton: false,
				centerVertical: true,
				buttons: {
					retry: {
						label: "Retry",
						className: "btn-success",
						callback: function () {
							$(this).modal("hide");
							app.plugins.LayerEditor.executeWFSTransaction(added, modified, removed, callback);
						}
					},
					cancel: {
						label: "Cancel",
						className: "btn-danger",
						callback: function () {
							app.plugins.LayerEditor.editableLayer.getSource().refresh();
							$(this).modal("hide");
						}
					}
				}
			});
		});
	}

	/**
	 * Function populateFeatureList
	 * @param {Array} features
	 *
	 * Populate the side bar with a list of features possibly
	 * from different layers. The user will then have the option
	 * to copy into the editable layer.
	 */
	populateFeatureList(layers) {
		// Show the editor tab
		activateSidebarTab(app.plugins.LayerEditor.tabNav);

		// Show sidebar immediately if desktop
		if (!isMobile()) showSidebar();

		// Empty any existing results
		$("#le-copying-container").empty();
		$("#le-copying-container").show();

		// loop through the layers
		layers.forEach((layer) => {
			const numFeatures = layer.features.features.length;
			const title = `<div class="title"><i class="oi oi-plus"></i>${layer.title}</div><span class="badge bg-primary number rounded-pill">${numFeatures}</span>`;

			const titleEl = $('<li class="features list-group-item d-flex justify-content-between align-items-center"></li>')
				.html(title)
				.data("geom", layer.features)

			// Highlight features on map
			.on("mouseenter", (e) => {
				const geom = $(e.target).data("geom"); // Grab bound data
				const features = new ol.format.GeoJSON().readFeatures(geom);
				features.forEach((feature) => highlightFeature(feature, true));
			})

			// Remove highlighed features from map
			.on("mouseleave", (e) => {
				clearHighlightedFeatures();
			})

			// Add to editable layer
			.on("click", (e) => {
				const geom = $(e.target).data("geom"); // Grab bound data

				// Refresh editable layer on callback
				const callback = (res) => {
					app.plugins.LayerEditor.editableLayer.getSource().refresh();
				};

				// Read the features
				const copiedFeatures = new ol.format.GeoJSON().readFeatures(geom);

				// Get editable layer's attrubute transforms (if any)
				var attributeTransforms = app.plugins.LayerEditor.editableLayer.get("attributeTransforms");

				// Loop thru the source (copied) features and prepare them for posting to the target
				$.each(copiedFeatures, function (index, copiedFeature) {
            
					// Loop thru each copied feature's property
					$.each(copiedFeature.getProperties(), function (key, property) {
						// Set the source feature's geometry name to the target feature's geometry name.  This is
						// a total hack as OpenLayers does not fully respect "setGeometryName" alone, so one has
						// to unset and reassign the geometry manually - barf :-(
						if (key == copiedFeature.getGeometryName()) {
							copiedFeature.unset(key);
							copiedFeature.set(
								app.plugins.LayerEditor.editableLayer.getSource().geometryColumnName,
								property
							);
							copiedFeature.setGeometryName(
								app.plugins.LayerEditor.editableLayer.getSource().geometryColumnName
							);
						}

						// If the editable layer has attribute transform configuration ste, remap source property to target property
						if (attributeTransforms) {
							$.each(attributeTransforms, function (toAttribute, fromAttribute) {
								if (key == fromAttribute) {
									copiedFeature.unset(key);
									copiedFeature.set(toAttribute, property);
								}
							});
						}
					});
				});

				// Add as an wfs transaction
				this.executeWFSTransaction(copiedFeatures, null, null, callback);
			});

			$("#le-copying-container").append(titleEl);
		});
	}

	/**
	 * Function: toggleEditorFunction
	 * @param (string) action
	 * @returns () nothing
	 * Function to toggle (activate) an editing function based on passed action
	 */
	toggleEditorFunction(action) {
		
		/**
		 * Function: copyFeatures
		 * @param (object) searchFeature
		 * @returns () nothing
		 * Function copy features
		 */
		const copyFeatures = (searchFeature) => {
			// Show map spinner;
			showMapSpinner();

			// Count the number of available visible map overlay layers
			let availableLayerCount = 0;
			$.each(app.map.getLayers().getArray(), function (index, layer) {
				// Bail if not an acceptable visible overlay layer
				if (layer.get("type") != "overlay" || layer.get("visible") !== true || typeof layer.getSource().getFeatureInfoUrl != "function") return;

				// Made it here, count the layer
				availableLayerCount++;
			});

			// Query each available visible overlay layer for features
			var collector = [];
			$.each(app.map.getLayers().getArray(), function (index, layer) {
				// Bail if not an acceptable visible overlay layer
				if (layer.get("type") != "overlay" || layer.get("visible") !== true || typeof layer.getSource().getFeatureInfoUrl != "function") return;

				// Define the layer url
				var layerUrl;
				if (layer.getSource() instanceof ol.source.TileWMS) {
					layerUrl = layer.getSource().getUrls()[0]; // TileWMS
				} else if (layer.getSource() instanceof ol.source.ImageWMS) {
					layerUrl = layer.getSource().getUrl(); // ImageWMS
				}
				layerUrl = layerUrl.replace(new RegExp("/ows", "ig"), "/wfs");
				layerUrl = layerUrl.replace(new RegExp("/wms", "ig"), "/wfs");

				// Get the typeName (layers) which will often be a combo of namespace and layer name (i.e. hwy:DSA_CONTRACT_AREA)
				var typeName = layer.getSource().getParams().LAYERS;

				// Get the name of the geometry column name
				var geometryField;
				$.each(layer.get("attributes"), function (index, attribute) {
					if (attribute.type.startsWith("gml:")) {
						geometryField = attribute.name;
					}
				});

				// Skip layer if layer has no geometry field defined
				if (geometryField == null) {
					logger(
						"ERROR",
						app.plugins.LayerEditor.name + ": " + layer.get("title") + " does not have a geometry field defined"
					);
					return;
				}

				// Get the layer title
				var title = layer.get("title");

				// Transform the passed feature (which is in map coords) into layer's coordinate system
				var featureInLayerCoords = transformFeature(
					searchFeature,
					app.map.getView().getProjection().getCode(),
					layer.get("nativeProjection")
				);
				var wktFormat = new ol.format.WKT();
				var searchWKT = wktFormat.writeGeometry(
					featureInLayerCoords.getGeometry()
				);

				// Issue the GetFeature request
				$.ajax({
					type: "GET",
					url: layerUrl,
					timeout: 10000,
					dataType: "json",
					data: {
						service: "WFS",
						version: "1.1.0",
						request: "GetFeature",
						typeNames: typeName,
						outputFormat: "application/json",
						maxFeatures: 1000,
						srsName: app.map.getView().getProjection().getCode(),
						cql_filter: "INTERSECTS(" + geometryField + "," + searchWKT + ")"
					},
					xhrFields: {
						withCredentials: layer.get("withCredentials") ? layer.get("withCredentials") : false,
					},
				})
				.done(function (features) {
					// Add returned features to collector
					collector.push({ title, features });

					// Send all collected features to the sidebar when everything is done
					if (collector.length == availableLayerCount) {
						hideMapSpinner();
						app.plugins.LayerEditor.populateFeatureList(collector);
					}
				})
				.fail(function (jqxhr, settings, exception) {
					// Log the error
					logger(
						"ERROR",
						app.plugins.LayerEditor.name + ": Could not copy features from " + layer.get("title") + " - " + exception
					);

					// Add returned features to collector
					var emptyObj = new Object();
					collector.push({ title, emptyObj });

					// Send all collected features to the sidebar when everything is done
					if (collector.length == availableLayerCount) {
						hideMapSpinner();
						app.plugins.LayerEditor.populateFeatureList(collector);
					}
				});
			});
		}

		/**
		 * Function: toggleCopyFeature
		 * @param () none
		 * @returns () nothing
		 * Function to toggle the copy feature tool
		 */
		const toggleCopyFeature = () => {
			// Prepare for new map interaction
			this.turnEditingOff();

			// Copy based on a point click
			this.copyPoint = (e) => {
				// Proceed only if a map click
				if (!e.originalEvent.path[0].matches("canvas") && !$(e.originalEvent.path[0]).hasClass("ol-layer")) return;

				// If in box select mode get out.
				if (e.originalEvent.ctrlKey) return;

				// Transform the map click coordinate into a tiny polygon feature (in map
				// coordinates).  Use a radius of 2 units and transform to 16 edges.
				var polygon = ol.geom.Polygon.fromCircle(
					new ol.geom.Circle(e.coordinate, 2),
					16
				);
				var searchFeature = new ol.Feature(polygon);

				// Query for features
				copyFeatures(searchFeature);
			};

			// Copy based on drawing a box
			this.copyBox = (e) => {
				// Convert dragbox extent geometry into a feature
				var searchFeature = new ol.Feature({
					geometry: this.dragBox.getGeometry(),
				});

				// Query for features
				copyFeatures(searchFeature);
			};

			// The interaction for drawing a box
			this.dragBox = new ol.interaction.DragBox({
				condition: ol.events.condition.platformModifierKeyOnly,
			});

			// Redirect single map click
			redirectMapSingleClickFunction("alias", this.copyPoint);

			// Listen to box drag
			app.map.addInteraction(this.dragBox);
			this.dragBox.on("boxend", this.copyBox);
		};

		/**
		 * Function: toggleAddFeature
		 * @param (string) feature type
		 * @returns () nothing
		 * Function to toggle the add feature tool
		 */
		const toggleAddFeature = (featureType) => {
			// Prepare for new map interaction
			this.turnEditingOff();
			redirectMapSingleClickFunction("copy", null);

			// Determine which tool to build
			var type;
			switch (featureType) {
				case "point":
					type = "Point";
					break;
				case "linestring":
					type = "MultiLineString";
					break;
				case "polygon":
					type = "MultiPolygon";
					break;
			}

			// Define and add new map interactions
			this.draw = new ol.interaction.Draw({
				source: app.plugins.LayerEditor.editableLayer.getSource(),
				type: type,
				geometryName: app.plugins.LayerEditor.editableLayer.getSource().geometryColumnName
			});
			this.snap = new ol.interaction.Snap({
				features: this.snapableCollection
			});
			app.map.addInteraction(this.draw);
			app.map.addInteraction(this.snap);

			// Register map interaction listener
			this.draw.on("drawend", (e) => {
				// Get the feature
				var feature = e.feature;

				// Define the callback
				var callback = function (result) {
					app.plugins.LayerEditor.editableLayer.getSource().refresh(); // Refresh the layer
				};

				// Execute the transaction
				this.executeWFSTransaction([feature], null, null, callback);
			});
		};

		/**
		 * Function: toggleModifyFeature
		 * @param () none
		 * @returns () nothing
		 * Function to toggle the modify feature tool
		 */
		const toggleModifyFeature = () => {
			// Prepare for new map interaction
			this.turnEditingOff();
			redirectMapSingleClickFunction("alias", null);

			// Show the layer editor tab
			activateSidebarTab(app.plugins.LayerEditor.tabNav);

			// Determine what can be modified (as configured)
			var allowGeometryModification = false;
			var allowAttributeModification = false;
			if (app.plugins.LayerEditor.editableLayer.get("allowedModifications")) {
				if (app.plugins.LayerEditor.editableLayer.get("allowedModifications").geometry === true) allowGeometryModification = true;
				if (app.plugins.LayerEditor.editableLayer.get("allowedModifications").attributes === true) allowAttributeModification = true;
			}

			// Define, register, and add the SELECT map interaction
			this.select = new ol.interaction.Select({
				layers: [app.plugins.LayerEditor.editableLayer],
				multi: true,
				style: new ol.style.Style({
					fill: new ol.style.Fill({
						color: "rgba(255, 255, 255, 0.5)",
					}),
					stroke: new ol.style.Stroke({
						color: "#ffc400",
						width: 3,
					}),
					image: new ol.style.Circle({
						radius: 7,
						stroke: new ol.style.Stroke({
							color: "white",
							width: 2,
						}),
						fill: new ol.style.Fill({
							color: "#ffc400",
						})
					})
				})
			});
			this.select.on("select", (e) => {
				if (allowAttributeModification) {
					this.populateFeatureEditorSelector(this.select.getFeatures().getArray());
				}
			});
			app.map.addInteraction(this.select);

			// Define, register, and add the MODIFY map interaction
			if (allowGeometryModification) {
				this.modify = new ol.interaction.Modify({
					features: this.select.getFeatures(),
				});
				this.modify.on("modifyend", (e) => {
					this.executeWFSTransaction(null, e.features.array_, null);
				});
				app.map.addInteraction(this.modify);
			}

			// Define and add the SNAP map interaction
			if (allowGeometryModification) {
				this.snap = new ol.interaction.Snap({
					source: app.plugins.LayerEditor.editableLayer.getSource(),
				});
				app.map.addInteraction(this.snap);
			}
		}

		/**
		 * Function: toggleDeleteFeature
		 * @param () none
		 * @returns () nothing
		 * Function to toggle the delete feature tool
		 */
		const toggleDeleteFeature = () => {
			// Prepare for new map interaction
			this.turnEditingOff();
			redirectMapSingleClickFunction("alias", null);

			// Turn on red highlight on hover
			app.map.on("pointermove", this.highlightFeatureOnHover);

			// Define and add new map interactions
			this.delete = new ol.interaction.Select({
				layers: [app.plugins.LayerEditor.editableLayer],
			});
			app.map.addInteraction(this.delete);

			// Register map interaction listener
			this.delete.getFeatures().on("add", (f) => {
				this.editableLayer.getSource().removeFeature(f.element);
				this.redHighlightLayer.getSource().clear();
				this.executeWFSTransaction(null, null, [f.element]);
			});
		}

		/**
		 * Function: undoEdit
		 * @param () none
		 * @returns () nothing
		 * Function to undo last edit
		 */
		const undoEdit = () => {
			this.turnEditingOff();
			this.undoInteraction.undo();
		}

		/**
		 * Function: redoEdit
		 * @param () none
		 * @returns () nothing
		 * Function to redo last edit
		 */
		const redoEdit = () => {
			this.turnEditingOff();
			this.undoInteraction.redo();
		}

		/**
		 * Function: saveUndoRedo
		 * @param (object) event
		 * @returns () nothing
		 * Function to capture the feature edit/addition/delete and execute transaction
		 */
		const saveUndoRedo = (e) => {
			// Grab the most recent feature from the undoStack. This is required for feature modifications.
			const undoStack = e.target._undoStack;
			const undo = undoStack && undoStack[undoStack.length - 1] && undoStack[undoStack.length - 1].feature;

			// Need the most recent redo as well
			const redoStack = e.target._redoStack;
			const redo = redoStack && redoStack[redoStack.length - 1] && redoStack[redoStack.length - 1].feature;

			// Handle all the undo and redo combinations and send the appropriate transaction
			const feature = e.action.feature;
			const type = e.type;
			const action = e.action.type;
			switch (`${type}|${action}`) {
				case "undo|removefeature": // feature addition
					this.executeWFSTransaction([feature], null, null);
					break;
				case "undo|blockend": // feature modificiation
					this.executeWFSTransaction(null, [undo], null);
					break;
				case "undo|addfeature": // Feature deletion
					/**
					* This is a gnarly work around for a bug
					* in the undo/redo plugin.
					* If the user hit's undo with no transactions
					* in the current session... Features get removed
					* based on a high->low ID order... irrespective of
					* how they were edited in previous sessions.
					*/
					const id = parseInt(feature.id_.match(/.*\.(\d+)/)[1]) || 0;
					if (id <= app.plugins.LayerEditor.editableLayerTopId) {
						this.undoInteraction.redo();
						// Recalculate the top ID
						setTimeout(() => {
							app.plugins.LayerEditor.findEditableLayerTopId();
						}, 200);
					} else {
						this.executeWFSTransaction(null, null, [feature]);
					}
					break;
				case "redo|addfeature": // feature addition
					this.executeWFSTransaction([feature], null, null);
					break;
				case "redo|blockstart": // feature modification
					this.executeWFSTransaction(null, [redo], null);
					break;
				case "redo|removefeature": // feature deletion
					this.executeWFSTransaction(null, null, [feature]);
					break;
			}
		}

		/**
		 * Function: throttle
		 * @param (object) event
		 * @returns () nothing
		 * Function to stop multiple Undo/Redo events from getting to Geoserver.
		 * This is a work around for a bug in the OpenLayers plugin that increases
		 * an event stack each time the undo/redo feature is used.
		 */
		const throttle = (e, t) => {
			clearTimeout(this.undoTimer);
			this.undoTimer = setTimeout(() => saveUndoRedo(e), 100);
		};

		// Toggle edit function based on passed action
		switch (action) {
			case "polygon": // Fall-through for all feature additions
			case "point":
			case "linestring":
			case "circle":
				toggleAddFeature(action);
				break;
			case "modify":
				toggleModifyFeature();
				break;
			case "delete":
				toggleDeleteFeature();
				break;
			case "undo":
				undoEdit(); // Undo last edit
				break;
			case "redo":
				redoEdit(); // Redo last edit
				break;
			case "copy":
				toggleCopyFeature();
				break;
			default:
				this.turnEditingOff(); // reset
		}

		// Throttle redo/undo requests
		//this.undoInteraction.on("redo", throttle);
		//this.undoInteraction.on("undo", throttle);
	}
	
	/**
	 * Function: updateLayerCounter
	 * @param (object) spinner, (int) layerCounter 
	 * @returns () nothing
	 * Function that updates the layerCounter and spinner when populating the layer selector dropdown
	 */
	updateLayerCounter(spinner, layerCounter, layerArraySize){
		layerCounter++;
		if(layerCounter == layerArraySize) {
			spinner.stop();
			$("#le-editable-layer-select").prop("disabled", false);
		} 
		return layerCounter;
	}

	/**
	 * Function: populateEditableLayerSelect
	 * @param () none
	 * @returns () nothing
	 * Function that populates the editable layer select control with layers configured to be editable
	 */
	populateEditableLayerSelect() {
		// Empty the select control
		$("#le-editable-layer-select").empty();

		// Add default no editable layer option
		$("#le-editable-layer-select").append(new Option("No Editable Layer", -1));

		// Loop through the map layers
		var layerId;
		var typeName;
		var layerCounter = 0
		var layerArray = app.map.getLayers().getArray();
		var layerArraySize = layerArray.length;

		// Start the spinner
		app.sidebarSpinner = new Spinner(app.spinnerOptionsMedium).spin($("#Editor-tab-content")[0]);

		// Disable the layer editor selection dropdown 
		$("#le-editable-layer-select").prop("disabled", true);

		// Loop throuh the layers and add them to the layer selector
		$.each(layerArray, function (index, layer) {
			// If the layer is editable
			if (layer.get("editable")) {
				// Get the layer ID
				layerId = ol.util.getUid(layer);

				// Get the layer name
				app.config.map.layers.forEach( (l)=>{ 
					if (l.get("title")==layer.get("title")) {
						typeName = app.config.map.layers[0].getSource().layerNamespace+":"+app.config.map.layers[0].getSource().layerName
					}
				});	

				// Now check if the user has permission to edit the layer
				// by sending a GetFeatureWithLock request. Here we set count to 0
				// to minimize the query speed.
				const xmlString = `
					<wfs:GetFeatureWithLock service='WFS' version='2.0.0' 
					handle='GetFeatureWithLock-tc1' expiry='1' resultType='results' count='0'
					xmlns:topp='http://www.openplans.org/topp'
					xmlns:fes='http://www.opengis.net/fes/2.0'
					xmlns:wfs='http://www.opengis.net/wfs/2.0'
					valueReference='GEOMETRY'>
					<wfs:Query typeNames='${typeName}'/>
					</wfs:GetFeatureWithLock>
					`;

				$.ajax({
					type: "POST",
					contentType: "text/plain",
					xhrFields: {
						withCredentials: true
					},
					crossDomain: true,
					url: layer.getSource().layerUrl,
					data: xmlString,
					async: false
				}).done(function (response) {
					// Add this layer as an editing option
					$("#le-editable-layer-select").append(
						new Option(layer.get("title"), layerId)
					);

					// Update the layer counter and stop the spinner if all layers have been checked
					layerCounter = app.plugins.LayerEditor.updateLayerCounter(app.sidebarSpinner, layerCounter, layerArraySize);

				}).fail(function (data, settings, exception) {
				// Create a log event message
					logger(
						"ERROR",
						app.plugins.LayerEditor.name + ": User could not validate permissions for " + layer.get("title") + " - " + exception
					);

					// Update the layer counter and stop the spinner if all layers have been checked
					layerCounter = app.plugins.LayerEditor.updateLayerCounter(app.sidebarSpinner, layerCounter, layerArraySize);
				});
			} else {
				// Update the layer counter and stop the spinner if all layers have been checked
				layerCounter = app.plugins.LayerEditor.updateLayerCounter(app.sidebarSpinner, layerCounter, layerArraySize);
			}
		});
	}

	/**
	 * Function: setEditableLayer
	 * @param (integer) layerId
	 * @returns () nothing
	 * Function that sets the editable layer based on user selection
	 */
	setEditableLayer(layerId) {
		// Reset editable layer stuff
		this.editableLayer = null;
		this.editableLayerTopId = null;
		this.WFSFormat = null;

		// Unregister the click event for all edit buttons (if they exist)
		$(".le-edit-btn").off("click");

		// Set the editable layer according to the passed layerId
		$.each(app.map.getLayers().getArray(), function (index, layer) {
			if (ol.util.getUid(layer) == layerId) {
				app.plugins.LayerEditor.editableLayer = layer;
			}
		});

		// If editable layer is null, then cleanup and bail
		if (!app.plugins.LayerEditor.editableLayer) {
			this.toggleEditControls(null);
			return;
		}

		// Make sure the editable layer is visible
		if (app.plugins.LayerEditor.editableLayer.getVisible() == false) {
			this.editableLayer.setVisible(true);

			// If layer controller plugin exists, then check on the layer there toolbar
			if (app.plugins.LayerController) {
				$(".lc-overlay-chkbox").each(function () {
					if ($(this).attr("layerId") == layerId) {
						$(this).prop("checked", true);
						rememberState();
					}
				});
			}
		}

		// Show the editing controls configured for this layer
		if (app.plugins.LayerEditor.editableLayer.get("controls")) {
			this.toggleEditControls(app.plugins.LayerEditor.editableLayer.get("controls"));
		} else {
			return;
		}

		// Register editable layer change listener
		app.plugins.LayerEditor.editableLayer.getSource().on("change", (e) => {
			app.plugins.LayerEditor.findEditableLayerTopId();
		});

		// Register the click event for all edit buttons
		$(".le-edit-btn").on("click", (e) => {
			// Get the button and it's intended action
			var btn;
			if ($(e.target).is("img")) {
				btn = $(e.target).parent();
			} else {
				btn = $(e.target);
			}
			var action = btn.data("action");

			// If there is a copy event, turn it off
			if (this.copy) {
				app.map.un("pointerup", this.copy);
			}

			// 1. If already active turn off and turn default map click function back on.
			// 2. Otherwise turn any other button off and turn the new button on.
			// 3. Don't highlight the attribute button. ?????????
			if (btn.hasClass("active")) {
				btn.removeClass("active");
				if (action === "snap") {
					// If turning off snapping clear the snapping collection
					this.snapableCollection.clear();
				} else {
					// Otherwise turn off all the buttons
					this.toggleEditorFunction("reset");
				}
			} else {
				if (action === "snap") {
					// If turning on the snapping button fill snapping collection
					// Fill the snapable array
					this.snapable(e);
				}
				$(".le-edit-btn").not('[data-action="snap"]').removeClass("active");
				if (action !== "attributes" && action !== "undo" && action !== "redo") btn.addClass("active");
				this.toggleEditorFunction(action);
			}
		});

		// Add the undo and redo logic (disbaled for now - has issues)
		//this.undoInteraction = new ol.interaction.UndoRedo();
		//app.map.addInteraction(this.undoInteraction);
	}

	/**
	 * Function: toggleEditControls
	 * @param (object) controls
	 * @returns () nothing
	 * Function that hides or shows (toggles) the editing controls
	 */
	toggleEditControls(controls) {
		// Turn editing off by default
		this.turnEditingOff();

		// Deactivate and hide all controls
		$(".le-edit-btn").each(function () {
			var btn = $(this);
			if (btn.hasClass("active")) btn.removeClass("active");
			btn.hide();
		});

		// Hide all control set group containers
		$(".le-edit-btn-grp")
			.removeClass("in")
			.addClass("out")
			.on("animationend", (e) => {
			$(e.target).addClass("hidden");
		});

		// Bail if no controls were passed
		if (!controls) return;

		// Build the toolbar
		var keys = Object.keys(controls);
		keys.forEach((key) => {
			var btn = $("div[data-action='" + key + "']");
			if (controls[key]) {
				btn.show();
				if (btn.parent().hasClass("out")) {
					btn.parent().removeClass("out").addClass("in")
					.on("animationend", (e) => {
						$(e.target).removeClass("hidden");
					});
				}
			} else {
				btn.hide();
			}
		});
	}

	/**
	 * Function: findEditableLayerTopId
	 * @param () none
	 * @returns () nothing
	 * Function that finds the editable layer's top ID.  Used for preventing undo button from going to far.
	 */
	findEditableLayerTopId() {
		if (!app.plugins.LayerEditor.editableLayerTopId) {
			if (app.plugins.LayerEditor.editableLayer) {
				var features = app.plugins.LayerEditor.editableLayer
				.getSource()
				.getFeatures();
				if (features.length > 0) {
					var topId = 0;
					$.each(features, function (index, feature) {
						if (feature.id_) {
							var currentFeatureId = parseInt(feature.id_.match(/.*\.(\d+)/)[1]) || 0;
							if (currentFeatureId > topId) topId = currentFeatureId;
						}
					});
					app.plugins.LayerEditor.editableLayerTopId = topId;
				}
			}
		}
	}

	/**
	 * Function: snapable
	 * If the snapping tool is on, clear out the snapable features collection
	 * and repopulate according to what layers are visible.
	 * @param {*} e Zoom or button click event. The button click is fired
	 * 		when snapping is turned on. The zoom event happens on map move
	 * 		when snapping is turned on.
	 */
	snapable(e) {
		const active = $(
			'#le-digitize-toolbar .le-edit-btn[data-action="snap"]'
		).hasClass("active");

		// If turning on snapping button
		const snapClick = e.type === "click";

		if (!active && !snapClick) return; // Exit if tool isn't on

		// Clear the snapable collection
		app.plugins.LayerEditor.snapableCollection.clear();

		// Add the editiable layer features to the snapable collection
		app.plugins.LayerEditor.editableLayer
			.getSource()
			.getFeatures()
			.forEach((f) => {
				app.plugins.LayerEditor.snapableCollection.push(f);
			});

		// Loop thru each map layer
		app.map.getLayers().forEach((layer) => {
			// Bail if not an acceptable visible overlay layer
			if (layer.get("type") != "overlay" || layer.get("visible") !== true || typeof layer.getSource().getFeatureInfoUrl != "function") return;

			// Define the layer url
			var layerUrl;
			if (layer.getSource() instanceof ol.source.TileWMS) {
				layerUrl = layer.getSource().getUrls()[0]; // TileWMS
			} else if (layer.getSource() instanceof ol.source.ImageWMS) {
				layerUrl = layer.getSource().getUrl(); // ImageWMS
			}
			layerUrl = layerUrl.replace(new RegExp("/ows", "ig"), "/wfs");
			layerUrl = layerUrl.replace(new RegExp("/wms", "ig"), "/wfs");

			// Get the typeName (layers) which will often be a combo of namespace and layer name (i.e. hwy:DSA_CONTRACT_AREA)
			var typeName = layer.getSource().getParams().LAYERS;

			// Define the request BBOX (from the current extent)
			const proj = app.map.getView().getProjection();
			const extent = app.map.getView().calculateExtent(app.map.getSize());
			const [x1, y1, x2, y2] = extent;
			const [lon1, lat1] = ol.proj.transform([x1, y1], proj, "EPSG:4326");
			const [lon2, lat2] = ol.proj.transform([x2, y2], proj, "EPSG:4326");
			const coords = `${lon1},${lat1},${lon2},${lat2}`;

			// Issue the GetFeature request
			$.ajax({
				type: "GET",
				url: layerUrl,
				timeout: 10000,
				dataType: "json",
				data: {
					service: "WFS",
					version: "1.1.0",
					request: "GetFeature",
					typeNames: typeName,
					outputFormat: "application/json",
					maxFeatures: 1000,
					srsName: app.map.getView().getProjection().getCode(),
					bbox: coords + ",EPSG:4326",
				},
				xhrFields: {
					withCredentials: layer.get("withCredentials") ? layer.get("withCredentials") : false
				},
			})
			.done(function (response) {
				// Add the response (features) to the snapable collection
				var features = new ol.format.GeoJSON().readFeatures(response);
				features.forEach((feature) => {
					app.plugins.LayerEditor.snapableCollection.push(feature);
				});
			})
			.fail(function (jqxhr, settings, exception) {
				logger(
					"ERROR",
					app.plugins.LayerEditor.name + ": Could not get features from " + layer.get("title") + " for snapping - " + exception
				);
			});
		});
	}

	/**
	 * Function: manageControls
	 * @param {Object} e OpenLayers zoom event
	 * @returns () nothing
	 * Some controls are only active a certain zoom levels.
	 * This function gets called after each movement of the map and
	 * toggle applicable controls.
	 */
	manageControls(e) {
		const zoom = app.map.getView().getZoom();
		if (zoom > 9) {
			$('#le-digitize-toolbar .le-edit-btn[data-action="snap"]').removeClass("disabled");
			app.plugins.LayerEditor.snapable(e);
		} else {
			$('#le-digitize-toolbar .le-edit-btn[data-action="snap"]').addClass("disabled");
		}
	}

	/**
	 * Function: highlightFeatureOnHover
	 * @param (object) event
	 * @returns () nothing
	 * Function to highlight a 'hovered feature in red
	 */
	highlightFeatureOnHover(e) {
		app.plugins.LayerEditor.redHighlightLayer.getSource().clear();
		app.map.forEachFeatureAtPixel(e.pixel, function (feature) {
			app.plugins.LayerEditor.redHighlightLayer.getSource().addFeature(feature);
		});
	}

	/**
	 * Function: refreshEditableLayer
	 * @param () none
	 * @returns () nothing
	 * Function to refresh the editable layer.
	 */
	refreshEditableLayer() {
		resetLayerStatistics(app.plugins.LayerEditor.editableLayer);
		app.plugins.LayerEditor.editableLayer.getSource().refresh();
	}

	/**
	* Function: addPlugin
	* @param () none
	* @returns () nothing
	* Function that adds the plugin tab to the sidebar
	*/
	addPlugin() {
		// Define Callback
		var callback = function (success, tabNav, tabContent) {
		
			// Bail if failed
			if (!success) {
				logger("ERROR", app.plugins.LayerEditor.name + ": Plugin failed to initialize");
				return;
			}

			// Set class variables
			app.plugins.LayerEditor.tabNav = tabNav;
			app.plugins.LayerEditor.tabContent = tabContent;

			// Populate the editable layer select
			app.plugins.LayerEditor.populateEditableLayerSelect();

			// Register the editable layer change handler
			$("#le-editable-layer-select").on("change", function (e) {
				var selectedLayerId = $("#le-editable-layer-select option:selected").val();
				app.plugins.LayerEditor.setEditableLayer(selectedLayerId);
			});
			
			// Register the editable feature change handler
			$("#le-editable-feature-select").on("change", function (e) {
				var featureId = $("#le-editable-feature-select option:selected").val();
				app.plugins.LayerEditor.showAttributeEditingForm(featureId);
			});
			
			// Register the save attribute btn handler
			$("#le-attribute-save-btn").on("click", function(e) {
				app.plugins.LayerEditor.executeWFSTransaction(null, [app.plugins.LayerEditor.editableFeature], null, function(success, res) {
					if (success === true) {
						$("#le-editable-feature-select").trigger("change");
					}
				});
			});

			// Copy the editing toolbar to the map viewport
			$("#le-digitize-toolbar").appendTo("#map .ol-viewport .ol-overlaycontainer-stopevent");

			// Listen to zoom event to toggle certain tools
			app.map.on("moveend", app.plugins.LayerEditor.manageControls);

			// Log success
			logger("INFO", app.plugins.LayerEditor.name + ": Plugin successfully loaded");
		};

		// Add the tab
		addSideBarTab(this.tabName, this.tabContentFile, callback);
	}
}